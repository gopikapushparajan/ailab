import itertools

class PuzzleState:
    def __init__(self, board, parent=None, move=None, depth=0):
        self.board = board
        self.parent = parent
        self.move = move
        self.depth = depth
        self.empty_pos = self._find_empty()

    def _find_empty(self):
        for r in range(3):
            for c in range(3):
                if self.board[r][c] == 0:
                    return r, c

    def is_goal(self, goal_board):
        return self.board == goal_board

    def get_neighbors(self):
        neighbors = []
        r, c = self.empty_pos
        moves = [(0, 1), (0, -1), (1, 0), (-1, 0)] # Right, Left, Down, Up

        for dr, dc in moves:
            new_r, new_c = r + dr, c + dc
            if 0 <= new_r < 3 and 0 <= new_c < 3:
                new_board = [row[:] for row in self.board]
                new_board[r][c], new_board[new_r][new_c] = new_board[new_r][new_c], new_board[r][c]
                neighbors.append(PuzzleState(new_board, self, (dr, dc), self.depth + 1))
        return neighbors

def solve_8_puzzle_iddfs(initial_board, goal_board):
    for depth_limit in itertools.count():
        print(f"Trying depth limit: {depth_limit}")
        result = dls(PuzzleState(initial_board), goal_board, depth_limit, set())
        if result:
            return result
    return None

def dls(current_state, goal_board, depth_limit, visited_in_dls):
    if current_state.is_goal(goal_board):
        return current_state

    if current_state.depth == depth_limit:
        return None

    visited_in_dls.add(tuple(map(tuple, current_state.board)))

    for neighbor in current_state.get_neighbors():
        if tuple(map(tuple, neighbor.board)) not in visited_in_dls:
            result = dls(neighbor, goal_board, depth_limit, visited_in_dls)
            if result:
                return result
    return None

# Example Usage:
initial_board = [[1, 2, 3], [4, 0, 6], [7, 5, 8]]
goal_board = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]

solution_node = solve_8_puzzle_iddfs(initial_board, goal_board)

if solution_node:
    path = []
    current = solution_node
    while current:
        path.append(current.board)
        current = current.parent
    path.reverse()
    for step in path:
        for row in step:
            print(row)
        print("---")
    print(f"Solution found in {solution_node.depth} steps.")
else:
    print("No solution found.")
