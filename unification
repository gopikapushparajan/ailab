import re


def is_variable(x):
    return isinstance(x, str) and x[0].islower() and x.isalpha()


def parse_term(term):
    # Parses a function or constant or variable into structured form
    term = term.strip()
    if '(' not in term:
        return term

    functor, args_str = term.split('(', 1)
    args = []
    depth = 0
    current = ''

    for ch in args_str[:-1]:  # skip last ')'
        if ch == ',' and depth == 0:
            args.append(parse_term(current.strip()))
            current = ''
        else:
            if ch == '(':
                depth += 1
            elif ch == ')':
                depth -= 1
            current += ch

    if current:
        args.append(parse_term(current.strip()))

    return (functor.strip(), args)


def occurs_check(var, x, subst):
    if var == x:
        return True
    elif isinstance(x, str):
        if x in subst:
            return occurs_check(var, subst[x], subst)
        return False
    elif isinstance(x, tuple):
        return any(occurs_check(var, arg, subst) for arg in x[1])
    return False


def substitute(x, subst):
    if isinstance(x, str):
        # If x is a variable and has a substitution, apply it recursively.
        # This handles chained substitutions like x -> y, y -> f(z).
        if x in subst:
            return substitute(subst[x], subst)
        else:
            # If it's not in the substitution, it's either a constant string
            # or a variable that hasn't been substituted yet.
            return x
    elif isinstance(x, tuple):
        functor, args = x
        return (functor, [substitute(arg, subst) for arg in args])
    return x


def unify(x, y, subst=None):
    if subst is None:
        subst = {}

    x = substitute(x, subst)
    y = substitute(y, subst)

    if x == y:
        return subst
    elif is_variable(x):
        if occurs_check(x, y, subst):
            raise ValueError(f"Occurs check failed for {x} in {y}")
        subst[x] = y
        return subst
    elif is_variable(y):
        if occurs_check(y, x, subst):
            raise ValueError(f"Occurs check failed for {y} in {x}")
        subst[y] = x
        return subst
    elif isinstance(x, tuple) and isinstance(y, tuple):
        if x[0] != y[0] or len(x[1]) != len(y[1]):
            raise ValueError(f"Functor mismatch: {x[0]} vs {y[0]}")
        for a, b in zip(x[1], y[1]):
            subst = unify(a, b, subst)
        return subst
    else:
        raise ValueError(f"Cannot unify {x} with {y}")


# ----- Test -----
x = parse_term("P(f(x), g(y), y)")
y = parse_term("P(f(g(z)), g(f(a)), f(a))")

print("Parsed terms:")
print("x =", x)
print("y =", y)

try:
    result = unify(x, y)
    print("\nUnification successful!")
    print("Substitution set:")
    for var, val in result.items():
        print(f"  {var} = {val}")
except ValueError as e:
    print("\nUnification failed:", e)
